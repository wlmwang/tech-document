# SSH 说明文档

## 简介
* SSH（Secure Shell）是一套协议标准，其具体的实现有很多，既有开源实现的 OpenSSH，也有商业实现方案。它主要用来实现两台机器之间的安全**登录**以及安全**数据传送**。其保证数据安全的原理是非对称加密。

* 传统的对称加密使用的是一套秘钥，数据的加密以及解密用的都是这一套秘钥，可想而知所有的客户端以及服务端都需要保存这套秘钥，泄露的风险很高，而一旦秘钥便泄露便保证不了数据安全。

* 非对称加密解决的就是这个问题，它包含两套秘钥：公钥以及私钥。其中公钥用来加密，私钥用来解密，并且通过公钥计算不出私钥，因此私钥谨慎保存在服务端，而公钥可以随便传递，即使泄露也无风险。（流程是单向：公钥加密，私钥解密）。

* 保证 SSH 安全性的方法，简单来说就是客户端和服务端**各自生成**一套私钥和公钥，并且互相**交换公钥**，这样每一条发出的数据都可以用对方的公钥来加密，对方收到后再用自己的私钥来解密。
> 此种方案并非被主流的SSH所使用。（主流实现使用rsa+aes方式：rsa仅用来传输aes对称加密里的密钥，双方实际传输的数据是使用aes对称加密（你有没有想到https，这就对了！）。此种算法，本文也有说明）。


## SSH 会话建立。双方交换公钥

![avatar](images/ssh_rsa.jpg)

![avatar](images/ssh_conn.jpg)

1. 客户端发起一个 TCP 连接请求。默认端口号为 22 。
2. 服务端返回自己公钥、以及一个会话ID（这一步**客户端得到了服务端公钥**）。
3. 客户端收到服务公钥后，会在自己的 **known_hosts** 文件进行搜索。如果找到了相同的公钥，则说明此前连接过该服务器。如果没有找到，则会在终端上显示一段警告信息，由用户来决定是否继续连接。
4. 接下来，客户端用自己的公钥**异或**会话ID，计算出一个值，再用服务端的公钥加密。
5. 客户端发送加密后的值到服务端，服务端用私钥解密。
6. 服务端用解密后的值**异或**会话ID，计算出客户端的公钥（这一步**服务端得到客户端公钥**）。

* 至此，双方各自持有三个秘钥：分别为自己的一对公、私钥，以及对方的公钥，之后的所有通讯都会被加密。
	* 这里有一个有趣的地方，两台机器第一次使用 SSH 连接时，当服务端返回自己的公钥（第2步）的时候，客户端会有一条信息提示：大意是无法验证对方是否可信，并给出对方公钥的 MD5 编码值，问是否确定要建立链接。
	* 这是因为 SSH 虽然传输过程中很安全，但是在首次建立链接时并没有办法知道发来的公钥是否真的来自自己请求的服务器，如果有人在客户端请求服务器后拦截了请求，并返回自己的公钥冒充服务器，这时候如果链接建立，那么所有的数据就都能被攻击者用自己的私钥解密了。这也就是所谓的中间人攻击。

## SSH 登录请求
 * SSH 账号密码登录
	* ![avatar](images/ssh_login_passwd.jpg)
		* 服务端收到登录请求后，首先互换公钥，详细步骤如上一节所述。
		* 客户端用服务端的公钥加密账号、密码并发送。
		* 服务端用自己的秘钥解密后得到账号、密码，然后进行验证。
		* 服务端用客户端的公钥加密验证结果并返回。
		* 客户端用自己的秘钥解密后得到验证结果。

 * SSH 公钥登录
 	> 方便客户端程序连接到服务器，这时候用密码登录就比较不方便，一是需要处理输入密码的问题；二是需要想办法安全的储存密码到程序里，这种情况下便可以利用公钥来进行无密码登录。
 	* ![avatar](images/ssh_login_pub.jpg)
		* 客户端用户必须**手动地将自己的公钥添加到服务器**上一个名叫**authorized_keys**的文件里。顾名思义，这个文件保存了所有可以远程登录的机器的公钥。
			* 客户端发起登录请求（ssh 用户名@服务端主机名或者IP），并且发送一个自己**公钥指纹**（具有唯一性，但不是公钥）。
			* 服务端根据**公钥指纹**检测公钥是否保存在**authorized_keys**中。
			* 若存在，服务端便生成一段**随机字符串**，然后利用**客户端公钥（客户端事先给的）**加密并返回。
			* 客户端收到后用自己的私钥解密出随机字符串，再利用**服务端公钥**加密后发回。
			* 服务端收到后用自己的私钥解密出随机字符串，如果与原始字符串匹配，则验证通过。



******************************************************************************************************************

## SSH 会话建立。RSA+AES 方式
1. 客户端发起一个 TCP 连接，默认端口号为 22

2. 服务端收到连接请求后，将自己的一些关键信息发给客户端。这些信息包括：
	* 服务端**自己的公钥**：客户端在收到这个公钥后，会在自己的 "known_hosts" 文件进行搜索。如果找到了相同的公钥，则说明此前连接过该服务器。如果没有找到，则会在终端上显示一段警告信息，由用户来决定是否继续连接。
		```
			vagrant@vagrant:~$ ssh kfs-web The authenticity of host 'kfs-web (192.168.1.167)' can't be established. 
			ECDSA key fingerprint is SHA256:Ql/KnGlolY9eCGuYK3OX3opnSyJQzsbtM3DW/UZIxms. Are you sure you want to 
			continue connecting (yes/no)?
		```
	* 服务器所支持的加密算法列表：客户端根据此列表来决定采用哪种加密算法。

3. 生成会话的对称密钥。此时，客户端已经拥有了服务端的公钥。接下来，客户端和服务端需要协商出一个双方都认可的密钥，并以此来对双方后续的通信内容进行加密。
	* 密钥协商是通过 Diffie-Hellman 算法来实现的。具体过程是：
		* 服务端和客户端共同选定一个大素数，叫做种子值。
		* 服务端和客户端各自独立地选择另外一个只有自己才知道的素数。
		* 双方使用相同的加密算法（如AES），由种子值和各自的私有素数生成一个密钥值，并将这个值发送给对方。
		* 在收到密钥值后，服务端和客户端根据种子值和自己的私有素数，计算出一个最终的密钥。这一步由双方分别独立进行，但是得到的**结果应该是相同**的。
		* 双方使用上一步得到的结果作为密钥来加密和解密通信内容。

4. 接下来，客户端将**自己的公钥ID（指纹）**发送给服务端，服务端**对客户端的合法性进行验证**：
	* 服务端在自己的 "authorized_keys" 文件中搜索与**客户端匹配的公钥**。
	* 如果找到了，服务端用这个客户端公钥加密一个**随机数**，并把加密后的结果发送给客户端。
	* 如果客户端持有正确的私钥，那么它就可以对消息进行解密从而**获得这个随机数**。
	* 客户端由这个随机数和当前的会话ID共同**生成一个MD5值**。
	* 客户端把这个 MD5 值发给服务端。
	* 服务端同样用会话ID和原始的随机数计算 MD5 值，并与客户端发过来的值进行对比。如果相等，则验证通过。

5. 至此，通信双方完成了加密信道的建立，可以开始正常的通信了。通信过程使用步骤3中生成的密钥。

* 如果此时你想到了https就对了！除了没有 CA 数字签名，可以说基本相同了。当然你也可以认为SSH中都是不用数字签名，我们自己人工认证！还记得首次连接，输入的那个yes？那就是你的认证，要负责的！


## Linux 配置密钥
```
// 本地生成密钥对（不指定 -f 默认为当前用户的 ~/.ssh/ 目录下）
$ ssh-kengen -t rsa [-f ~/.ssh/id_rsa]

// 拷贝公钥到服务端（用户名+密码方式）
$ scp ~/.ssh/id_rsa.pub remote-user@remote-host:/home

// 把公钥加入授权列表（服务端中操作）
$ touch ~/.ssh/authorized_keys
$ chmod 600 ~/.ssh/authorized_keys
$ cat /home/id_rsa.pub >> ~/.ssh/authorized_keys  // 追加方式


// 使用 ssh-copy-id 工具直接把本机的公钥追到 remote-host 的 remote-user 用户 ~/.ssh/authorized_keys 里
$ ssh-copy-id -i ~/.ssh/id_rsa.pub remote-user@remote-host
```

* 涉及文件说明
```
id_rsa：保存私钥
id_rsa.pub：保存公钥
authorized_keys：保存已授权的客户端公钥
known_hosts：保存已认证的远程 host key（每个 SSH Server 都有一个 secret, unique ID, 称为host key）
	# known_hosts 内容格式如：domain name+encryption algorithm+host key
	example.hostname.com ssh-rsa AAAAB4NzaC1yc2EAAAABIwAAAQEA...
```


## 登录
```
// 以用户名user，登录远程主机host
$ ssh user@host

// 本地用户和远程用户相同，则用户名可省去
$ ssh host

// ssh默认端口 22 ，可以用参数 p 修改端口
$ ssh -p 2222 user@host
```