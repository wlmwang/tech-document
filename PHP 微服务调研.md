# PHP 微服务调研
## 什么是Swoole？为什么要引入Swoole？引入Swoole后性能一定会提升吗？
* Swoole是标准的PHP扩展。但与普通扩展不同的是，Swoole扩展在运行后会接管PHP的控制权，进入事件循环。当I/O事件发生后，底层会自动回调指定的PHP函数。
* Swoole为开发者提供了丰富的工具集。主要包括有，Server（TCP/UDP/HTTP等服务器）、Client（TCP/UDP/HTTP等客户端）、Process（进程管理器）、Table（共享内存IPC）、Event（事件循环API）以及Coroutine（协程）。
	* 这些特性中，Server、Client作为Swoole的核心，提供着最基础的功能；Process、Table、Event作为Swoole的集成模块，能让服务端的开发更加完整；而Coroutine则是Swoole的灵魂，是其得以流行的关键。倘若没有Coroutine的能力，Swoole极有可能仅是一个普通的项目，大概率最后也不会出现在大众视野当中。当然Swoole开发者也非常清楚这点，早在2.0版本就将Coroutine内置到其核心模块中，到4.0版本更是将其默认开启，并为开发者提供一键Hook绝大多数PHP原生函数接口的协程化（也包括很多常用扩展，如MySQL、Redis等）。
* 传统的FastCGI架构都是同步阻塞模型。比如最常见的PHP-FPM ，Master进程将请求分发给空闲的Worker工作进程，工作进程accept阻塞返回后，进入PHP的”经典”执行流程（编译opcode、运行opcode。初始化所有安装模块->加载执行业务代码->回收资源：MINIT -> RINIT -> RSHUTDOWN -> MSHUTDOWN）。即，在一次完整请求处理流中，该Worker是以同步阻塞的方式运行。也就是说，系统的并发能力取决于Worker进程的数量。
* 为了最大化发挥FastCGI架构优势，很多人都会选择静态配置Worker数量。于是在实际工作中，你不难发现，一个线上环境的PHP-FPM进程数有时可能达300个，甚至更多！这会导致系统资源大量消耗在这些“无意义”进程上下文切换上（是否想到了Apache）。另外，我们也会配置Opcache，来尽可能的减少重复PHP编译工作。以上2点优化，在一定程度上解决了重复的“初始化所有安装模块”、重复的“编译opcode”问题，但它却避免不了重复的“开发框架初始化”的工作。在一个中等规模框架中，框架自身初始化工作的性能损耗是不可忽略的！想象一下，每次处理请求时，你重复的设置env、重复的构建路由表、重复的实例化MySQL/Cache对象（请区分开持久连接）、最后再重复的析构之前构建的对象。作为对比，在C++开发中，一个函数形参对象是否使用引用传递、返回对象是否启用了RVO优化等等，都可能会成为优化的点。你是否觉得框架重复初始化是一件多么浪费资源的事呢！
* Swoole是一个Reactor架构的系统，典型的异步非阻塞模型，底层使用较为流行的epoll多路复用实现事件通知。加上自带的协程能力，更是让开发者可以轻松的写出同步非阻塞代码，“自动”兼顾高性能。同时，也由于Swoole使用的是异步非阻塞模型，在开启协程后，服务器上就可以开启少量的Worker进程即可发挥高性能（适用阻抗原则）。另外，Swoole在运行后会接管PHP的控制权，进入事件循环，且常驻内存，我们可以很方便的使框架的初始化工作只进行一次。
* 故而，在一个WEB应用中，引入Swoole后，性能一定会得到提升。但是能提升多少，还得取决于业务类型以及业务自身逻辑。如果一个业务是CPU密集型的，就不会有多少提升；如果一个业务自身逻辑就很复杂，提升可能也不会很明显（但一定是提升的）。

## 为什么要引入一个协程框架？是可选的，还是必须的？
* 第一个问题的答案，已经回答了Coroutine在Swoole中的地位及作用。这里再补充说明下：如果我们使用Swoole，但却不开启其协程的能力，会怎么样？这将导致构建在Swoole上的应用程序稍有不慎就会退化成同步阻塞模型，如同FastCGI，进而要开启大量进程来提高并发。若开发者为了不让这种情况发生，从而使用了Swoole提供的各种回调接口，最后也会导致代码的维护变得异常困难。与其这样，不如一开始就不要引入Swoole。打个比方，一个C开发者，觉得C++中STL很酷，于是将应用改成了C++，但没有使用class、template等特性。你细品下。
> 所以在你决定引入Swoole时，开启协程几乎是必须的。如果你认同这个的结论，引入协程框架几乎也是必须的。最低要求，你必须解决协程安全问题。
* 最后补充，传统的PHP与Swoole编程范式有着极大的不同，甚至有的还是相悖的！比如，传统的PHP静态变量在Swoole中就极有可能会出现问题！在协程环境中，甚至出现让人头疼“竞态条件”。在公共资源上（如MySQL/Cache），传统PHP使用的单例模式，在协程环境中，也是不可用的；而Swoole环境中为了解决这个问题而引入的连接池，在传统PHP中也是浪费的。就更不用说Task、Process等，在传统的PHP中压根就没有。

## 引入一个协程框架的成本如何？
* 本次引入协程框架初衷是为了迁移 SCF。有如下三个方案：
    * 迁移Java，必然是要重构项目的，此处不作讨论。
    * 迁移Swoole+Coroutine，是要重构项目的，可选择复用部分代码。
    * 仅迁移Swoole，并做透明化处理。即，兼容目前传统方式编写的 PHP 代码。
* 首先，Swoole协程带来的绝对成本（为什么一定要开启协程，请看之前描述）。
    * 将项目中的Swoole开启协程成本是很大的！这不仅仅是指编程上带来的少许变化；更重要的是编程范式上的变化，比如：开发人员必须要知道为什么不能用单例，什么是连接池、协程上下文以及为什么需要它们等等。
    * 也正因为成本的问题，我们建议在新起的项目中引入Swoole协程，或者等到项目重构的时候引入。
* 其次，要比较后两者方案，需要回答另外一个问题：为什么不能是一个兼容方案？
    * 确实，之前我们引入Swoole时，引入了一个非常方便swoole-thrift-server，构建了一个“Swoole运行容器”透明层，包括之后在迁移的传统 WEB 业务应用所引入的swoole-http-server也都延用了这一方案。但我们要清除一点的是，之所以它们能“透明”，前提是我们放弃了Swoole的一个重要特性 - 协程！甚至从实践来看，我们还放弃了Task、Process、Event等等所有Swoole相关、非PHP-FPM的工具！为什么？直接原因恰恰是其“透明”性造成的！没道理么？有道理。你细品下。
    * 引入一个新的编程范式，新的编程思维，是打破上面这个“尴尬”局面的最好契机！
* 最后，选择引入一个协程框架是明智的，最基础的原因是我们不能用了Swoole，却不开启协程！

## 为什么不自研一个框架，而选择swoft？ 
* 拥抱开源。贡献开源。优秀的开源项目是经得起考验的，并且是逐步演化而来的。这些成本，若自研，是需要团队投入的。
* 便于推广（公司的许多部门）。相比自研，使用广泛的开源代码，推广起来会容易的多。
* 摘抄自Swoft官方介绍：Swoft 通过长达三年的积累和方向的探索，把 Swoft 打造成 PHP 界的 Spring Cloud, 它是 PHP 高性能框架和微服务治理的最佳选择。它有类似 Spring Cloud 框架灵活的注解、强大的全局依赖注入容器、完善的服务治理、灵活强大的 AOP、标准的 PSR 规范实现等等。
	* 内置高性能网络服务器（Http/Websocket/RPC/TCP）
	* 灵活的组件功能
	* 强大的注解功能
	* 多样化的命令终端（控制台）
	* 强大的面向切面编程（AOP）
	* 容器管理，依赖注入（DI）
	* 灵活的事件机制
	* 基于PSR-7的HTTP消息的实现
	* 基于PSR-14的事件管理
	* 基于PSR-15的中间件
	* 国际化（i18n）支持
	* 简单有效的参数验证器
	* 高性能连接池（Mysql/Redis/RPC），自动重新连接
	* 数据库高度兼容Laravel的使用方式
	* Redis高度兼容Laravel的使用方式
	* 秒级定时任务
	* Session 管理
	* 进程池
	* 高效的任务处理
	* 灵活的异常处理
	* 强大的日志系统
	* 服务注册与发现
	* 配置中心
	* 服务限流
	* 服务降级
	* 服务熔断
	* Apollo
	* Consul

## 引入Swoft方案是什么？使用现状怎么样？

