# 题目描述
	给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。
	k 是一个正整数，它的值小于或等于链表的长度。
	如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。

	进阶：
	你可以设计一个只使用常数额外空间的算法来解决此问题吗？
	你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。


# 示例
	输入：head = [1,2,3,4,5], k = 2
	输出：[2,1,4,3,5]

	输入：head = [1,2,3,4,5], k = 3
	输出：[3,2,1,4,5]

	输入：head = [1,2,3,4,5], k = 1
	输出：[1,2,3,4,5]

	输入：head = [1], k = 1
	输出：[1]

# 提示
	列表中节点的数量在范围 sz 内
	1 <= sz <= 5000
	0 <= Node.val <= 1000
	1 <= k <= sz

# 算法
* 递归+翻转 - O(n^2)
```
class Solution {
    public ListNode reverseKGroup(ListNode head, int k) {
    	if (head == null || k <= 1) return head;
    	
    	ListNode curr = head, dummy;
    	for (int i = 1; curr != null; i++) {
    		if (i < k && curr.next == null) {
    			// 链表不足长度
    			return head;
    		} else if (i >= k) {
    			dummy = curr.next;
    			
    			// 断开链表，开始翻转
    			curr.next = null;
    			reverse(head);
    			
    			// head 为链表翻转后的尾节点
    			head.next = reverseKGroup(dummy, k);

    			// curr 为链表翻转后的头结点
    			return curr;
    		}
    		curr = curr.next;
    	}
    	return null;
    }
    
    // 链表翻转
    ListNode reverse(ListNode head) {
    	if (head == null) return null;
    	else if (head.next == null) return head;
    	
    	ListNode p1 = head, p2 = head.next;
    	head.next = null;
    	head = p2;
    	while (p2 != null && p2.next != null) {
    		head = p2.next;
    		p2.next = p1;
    		p1 = p2;
    		p2 = head;
    	}
    	if (p2 != null) p2.next = p1;
    	
    	return head;
    }
}
```